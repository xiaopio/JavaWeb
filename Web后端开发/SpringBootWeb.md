# Spring

# SpringBootWeb开发

需求：使用SpringBoot开发一个web应用，浏览器发起请求/hello后，给浏览器返回字符串”HelloWorld~“。

## 步骤

①创建springboot工程，并勾选web开发相关的依赖

②定义HelloController类，添加方法hello，并添加注解。

③测试运行

```java
@RestController
public class HelloController {
    @RequestMapping("/hello")
    public String hello() {
        System.out.println("Hello World~");
        return "Hello World~";
    }
}
```

# HTTP协议

**超文本传输协议**，规定了浏览器和服务器之间数据传输的规则。

**一、简单快速**

- 客户端向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有 GET、POST 等。例如，你在浏览器中输入一个网址，实际上就是向服务器发送了一个 GET 请求。
- 由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。

**二、灵活**

- HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。比如可以传输文本、图片、音频、视频等各种类型的数据。
- 可以根据实际需求，自定义请求头和响应头，实现各种特定的功能。

**三、无连接**

- 无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。
- 这种方式可以节省传输时间，提高效率，但也意味着每次请求都需要重新建立连接，可能会增加一些开销。

**四、无状态**

- HTTP 是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。
- 为了解决这个问题，引入了 Cookie 和 Session 等技术来保持状态。

**五、支持 B/S 及 C/S 模式**

- 在浏览器 / 服务器（B/S）模式中，HTTP 是浏览器与服务器之间通信的主要协议。用户通过浏览器向服务器发送 HTTP 请求，服务器接收请求并返回相应的 HTTP 响应。
- 在客户端 / 服务器（C/S）模式中，也可以使用 HTTP 进行通信。例如一些桌面应用程序可能会通过 HTTP 与服务器进行数据交互。

请求方式-GET：请求参数在请求行中，没有请求体。GET请求大小是有限制的。

请求方式-POST：请求参数在请求体中，POST请求大小是没有限制的。

## GET请求

**一、请求方式**

GET 请求通常用于从服务器获取资源。当你在浏览器地址栏中输入一个网址并回车时，浏览器默认会发送一个 GET 请求。例如，打开一个新闻网页，浏览器向新闻网站的服务器发送 GET 请求以获取该网页的 HTML 内容。

**二、请求参数传递**

1. URL 参数
   - GET 请求可以通过在 URL 的查询字符串中携带参数来向服务器传递信息。例如，`https://www.example.com/search?q=keyword&page=2`，这里的 “q=keyword” 和 “page=2” 就是查询参数，服务器可以根据这些参数来返回相应的搜索结果和指定页码的内容。
   - 查询参数以键值对的形式出现，多个参数之间用 “&” 符号连接。
2. 参数长度限制
   - 由于 URL 的长度有限制，所以 GET 请求携带的参数长度也受到一定限制。不同的浏览器和服务器对 URL 长度的限制可能不同，但一般来说，GET 请求的参数不宜过长。

**三、安全性与幂等性**

1. 安全性
   - GET 请求被认为是相对安全的，因为它只是从服务器获取资源，而不会对服务器上的资源进行修改、删除或添加等操作。但这并不意味着 GET 请求完全没有安全风险，例如，如果查询参数中包含敏感信息，可能会被第三方截获。
2. 幂等性
   - GET 请求是幂等的，即多次重复相同的 GET 请求应该产生与第一次请求相同的结果。这意味着无论你执行多少次相同的 GET 请求，服务器上的资源状态都不会因为这些请求而改变。

**四、可缓存性**

1. 缓存机制
   - GET 请求的响应结果可以被缓存。当客户端再次发送相同的 GET 请求时，如果缓存中有相应的响应，并且该响应没有过期，那么可以直接从缓存中获取结果，而无需再次向服务器发送请求。
   - 这可以大大提高性能，减少网络带宽的使用和服务器的负载。
2. 缓存控制
   - 服务器可以通过设置响应头中的缓存控制指令来控制 GET 请求的缓存行为。例如，设置 “Cache-Control: max-age=3600” 表示该响应可以在客户端缓存 1 小时。

## POST请求

**一、请求用途**

POST 请求通常用于向服务器提交数据，以进行数据的创建、更新等操作。比如在论坛上发表新帖子、在购物网站上提交订单、在社交平台上上传图片等场景中，都会使用 POST 请求。

**二、请求参数传递**

1. 请求体传参
   - POST 请求将数据放在请求体中进行传输，而不像 GET 请求那样将参数放在 URL 中。这样可以传输更大量的数据，并且对于一些敏感信息也更加安全，不容易被第三方轻易看到。
   - 请求体中的数据可以是各种格式，常见的有表单数据（application/x-www-form-urlencoded）、JSON 数据（application/json）等。
2. 参数格式灵活
   - 根据不同的需求，可以选择不同的参数格式进行数据提交。例如，使用表单数据格式时，可以方便地提交传统的 HTML 表单数据；而使用 JSON 数据格式则更适合与现代的前后端分离架构进行数据交互。

**三、安全性与幂等性**

1. 安全性
   - 相对 GET 请求，POST 请求在传输敏感信息时更加安全，因为数据不在 URL 中显示。但这并不意味着绝对安全，仍然需要通过加密等方式来确保数据的安全传输。
   - 如果未对数据进行加密处理，在网络传输过程中仍有可能被拦截和窃取。
2. 非幂等性
   - POST 请求一般不是幂等的，即多次重复提交相同的 POST 请求可能会产生不同的结果。例如，多次提交订单可能会导致创建多个相同的订单。

**四、可缓存性**

1. 缓存难度大
   - 通常情况下，POST 请求的响应较难被缓存。因为 POST 请求往往会导致服务器状态的改变，所以缓存其响应可能会导致不一致的结果。
   - 但在某些特定情况下，如果 POST 请求的结果是可预测的且不会对服务器状态产生副作用，也可以通过设置特定的缓存控制头来进行缓存。

## 请求响应

**一、响应结构**

1. 状态行
   - 包含 HTTP 版本、状态码和状态描述。例如，“HTTP/1.1 200 OK”，其中 “HTTP/1.1” 是协议版本，“200” 是状态码，表示请求成功，“OK” 是对状态码的描述。
   - 状态码是客户端了解请求处理结果的重要依据，不同的状态码代表不同的含义，如 404 表示资源未找到，500 表示服务器内部错误等。
2. 响应头
   - 提供关于响应的各种元信息，如内容类型、内容长度、缓存控制等。例如，“Content-Type: text/html; charset=utf-8” 表示响应的内容类型是 HTML 文本，字符编码为 UTF-8。
   - 响应头可以帮助客户端正确处理和理解响应内容，同时也可以用于控制缓存、设置安全策略等。
3. 响应体
   - 包含实际的响应数据，其内容根据请求的资源和服务器的处理结果而定。如果请求的是一个网页，响应体可能就是 HTML 代码；如果请求的是一张图片，响应体就是图片的二进制数据。

**二、响应类型**

1. 静态资源响应
   - 当客户端请求静态资源（如 HTML 文件、图片、CSS 文件、JavaScript 文件等）时，服务器会直接返回相应的文件内容。
   - 这些资源通常不会因为每次请求而改变，所以可以通过设置缓存控制头来提高响应速度和减少服务器负载。
2. 动态资源响应
   - 对于动态资源的请求，服务器需要根据请求参数和当前的业务逻辑进行处理，生成动态的响应内容。例如，一个电子商务网站的商品搜索页面，服务器会根据用户输入的搜索关键词从数据库中查询相关商品信息，并生成 HTML 页面返回给客户端。
   - 动态资源的响应时间通常比静态资源长，因为服务器需要进行更多的计算和处理。

**三、缓存机制**

1. 缓存控制
   - 服务器可以通过在响应头中设置缓存控制指令来控制客户端对响应的缓存行为。例如，“Cache-Control: max-age=3600” 表示该响应可以在客户端缓存 1 小时。
   - 客户端在接收到响应后，会根据缓存控制指令决定是否将响应缓存起来，以及在后续请求中是否使用缓存的响应。
2. 缓存验证
   - 当客户端不确定缓存的响应是否仍然有效时，可以向服务器发送缓存验证请求。例如，客户端可以在请求头中添加 “If-Modified-Since” 字段，告诉服务器上次获取该资源的时间。服务器会根据这个时间判断资源是否有更新，如果没有更新，就返回状态码 304，表示资源未改变，客户端可以使用缓存的响应。

**四、错误处理**

1. 错误状态码
   - 当服务器在处理请求过程中遇到错误时，会返回相应的错误状态码。例如，403 表示禁止访问，404 表示资源未找到，500 表示服务器内部错误等。
   - 客户端可以根据错误状态码采取相应的处理措施，如显示错误页面、重新发送请求等。
2. 错误响应体
   - 除了错误状态码，服务器还可以在响应体中提供更详细的错误信息，帮助客户端了解错误的原因和解决方法。例如，服务器可能会返回一个 JSON 格式的错误信息，包含错误码、错误描述和建议的解决方案等。

## 状态码

HTTP 状态码分为五大类，其含义如下：

**一、1xx 信息性状态码**

1. 100 Continue：表示目前为止一切正常，客户端可以继续发送请求或者忽略这个响应。
2. 101 Switching Protocols：服务器根据客户端的请求切换协议。通常是在 Upgrade 头中指定了新的协议后返回此状态码。

**二、2xx 成功状态码**

1. 200 OK：最常见的成功状态码，表示请求已成功，响应返回的是请求的资源。
2. 201 Created：表示请求成功并且服务器创建了新的资源。通常在 POST 请求成功创建一个实体时返回。
3. 202 Accepted：表示服务器已接受请求，但尚未处理。这个状态码通常用于异步处理的场景，比如任务被放入队列等待处理。
4. 204 No Content：表示请求成功，但响应没有实体内容。通常在 DELETE 请求成功后返回，表示资源已被删除。

**三、3xx 重定向状态码**

1. 301 Moved Permanently：表示请求的资源已被永久移动到新位置。客户端应使用新的 URL 进行后续请求。
2. 302 Found：表示请求的资源临时被移动到了其他位置。与 301 类似，但这个重定向可能是临时的。
3. 303 See Other：表示请求的资源可以在另一个 URL 上找到，客户端应该使用 GET 方法去获取这个资源。
4. 304 Not Modified：表示客户端的缓存资源仍然有效，服务器没有新的内容返回。通常在缓存验证的场景下使用。

**四、4xx 客户端错误状态码**

1. 400 Bad Request：表示客户端发送的请求有语法错误或无法被服务器理解。
2. 401 Unauthorized：表示请求需要用户认证。通常在没有提供正确的认证信息时返回。
3. 403 Forbidden：表示服务器理解请求，但拒绝执行。通常是由于权限不足导致。
4. 404 Not Found：表示服务器找不到请求的资源。
5. 405 Method Not Allowed：表示请求方法不被允许。例如，对一个只允许 GET 请求的资源发送了 POST 请求。

**五、5xx 服务器错误状态码**

1. 500 Internal Server Error：表示服务器内部错误，通常是服务器在处理请求时遇到了意外情况。
2. 501 Not Implemented：表示服务器不支持请求的功能。
3. 502 Bad Gateway：表示作为网关或者代理的服务器在尝试执行请求时，从上游服务器接收到了无效的响应。
4. 503 Service Unavailable：表示服务器暂时无法处理请求，通常是由于服务器过载或正在进行维护。
5. 504 Gateway Timeout：表示作为网关或者代理的服务器在等待上游服务器响应时超时。

## HTTP响应格式

**一、响应行**

1. 组成部分
   - 响应行由 HTTP 版本、状态码和状态描述组成。例如，“HTTP/1.1 200 OK”，其中 “HTTP/1.1” 是协议版本，“200” 是状态码，表示请求成功，“OK” 是对状态码的描述。
2. 作用
   - 向客户端传达请求处理的基本结果。客户端通过查看响应行的状态码和描述，可以快速了解请求是否成功以及大致的情况。不同的状态码代表不同的含义，如 200 表示成功，404 表示资源未找到，500 表示服务器内部错误等。

**二、响应头**

1. 组成部分
   - 响应头由一系列键值对组成，每个键值对代表一个特定的元信息。例如，“Content-Type: text/html; charset=utf-8” 表示响应的内容类型是 HTML 文本，字符编码为 UTF-8。
2. 作用
   - 提供关于响应的各种详细信息，帮助客户端正确处理和理解响应内容。常见的响应头包括：
     - **Content-Type**：指定响应体的内容类型，如文本、图片、JSON 等。
     - **Content-Length**：指示响应体的长度，以字节为单位。
     - **Cache-Control**：控制缓存的行为，如是否允许缓存、缓存的有效期等。
     - **Last-Modified**：表示资源的最后修改时间，用于缓存验证。
     - **ETag**：实体标签，是资源的唯一标识符，也用于缓存验证。
     - **Location**：在重定向时，指定重定向的目标地址。

**三、响应体**

1. 组成部分
   - 响应体包含实际的响应数据，其内容根据请求的资源和服务器的处理结果而定。可以是文本、二进制数据或其他任何格式的数据。
2. 作用
   - 承载服务器返回给客户端的具体内容。例如，如果请求的是一个网页，响应体可能就是 HTML 代码；如果请求的是一张图片，响应体就是图片的二进制数据；如果请求的是一个 API，响应体可能是 JSON 格式的数据，包含请求的结果信息。

客户端在接收到 HTTP 响应后，会首先解析响应行，了解请求的基本结果。然后，客户端会读取响应头，获取关于响应的各种元信息，并根据这些信息来决定如何处理响应体。例如，如果响应头中的 “Content-Type” 是 “image/jpeg”，客户端就知道响应体是一张 JPEG 图片，可以将其显示在网页上或者进行其他图片相关的操作。

## 常见响应头

**一、Content-Type（内容类型）**

- 表示响应体的内容类型。例如，“Content-Type: text/html; charset=utf-8” 表示响应的内容是 HTML 文本，字符编码为 UTF-8。常见的内容类型还有 application/json（JSON 数据）、image/jpeg（JPEG 图片）等。

**二、Content-Length（内容长度）**

- 指明响应体的长度（以字节为单位）。客户端可以根据这个值来确定响应数据的大小，以便正确地接收和处理响应。

**三、Cache-Control（缓存控制）**

- 用于控制缓存的行为。例如，“Cache-Control: max-age=3600” 表示响应可以在客户端缓存 1 小时。常见的指令还有 no-cache（不使用缓存）、no-store（不允许缓存）等。

**四、Content-Encoding（内容编码）**

- 作用：服务器使用 “Content-Encoding” 来告知客户端响应体采用了何种压缩方式，以便客户端能够正确地解压缩并处理响应内容。常见的压缩方式可以减少网络传输的数据量，提高传输效率，降低带宽消耗和响应时间。例如：gzip。

**五、Set-Cookie（设置 Cookie）**

- 服务器使用这个头来向客户端发送 Cookie。Cookie 可以用于存储用户状态、会话信息等。

## HTTP协议解析

